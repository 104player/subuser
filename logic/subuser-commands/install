#!/usr/bin/env python
# This file should be compatible with both Python 2 and 3.
# If it is not, please file a bug report.
import sys
import os

######################################################
programName = sys.argv[1]
home = os.path.expanduser("~")
######################################################

def showHelp():
 """
  Display a help message for the install mode of the subuser command.
 """ 
 print("""To install a package list it's name:
 $ subuser install vim

Options:
 --from-cache build this image using layers from the cache
 """)

def registerProgram(programName,programVersion):
 import os
 import json
 programRegistryPath=os.path.join(home,"subuser","installed-programs.json")
 if os.path.exists(programRegistryPath):
  programRegistryFile = open(programRegistryPath,"r")
  programRegistry = json.load(programRegistryFile)
  programRegistryFile.close()
 else:
  programRegistry = {}
 programRegistry[programName]=programVersion
 programRegistryFile = open(programRegistryPath,"w")
 json.dump(programRegistry,programRegistryFile)
 programRegistryFile.close()

def installProgram():
 """
 Build the docker image associated with a program and create a tiny executable to add that image to your path.
 """
 import os
 import subprocess
 import json
 
 print("Installing "+programName)

 # read permissions.json file
 permissionsFilePath = os.path.join(home,"subuser","subusers",programName,"permissions.json")
 permissionsFile = open(permissionsFilePath,"r")
 permissions=json.load(permissionsFile)
 permissionsFile.close()

 try:
  dependency = permissions["dependency"]
  subprocess.call(["subuser","install","--from-cache",dependency])
 except KeyError:
  pass

 # build+tag docker image
 programDir = getProgramSrcDir(programName)
 dockerImageDir = os.path.join(programDir,"docker-image")
 if fromCache:
  cacheArg = "--no-cache=false"
 else: 
  cacheArg = "--no-cache=true"
 subprocess.call(["docker","build","-rm",cacheArg,"--tag=subuser-"+programName+"",dockerImageDir])

 # Create a small executable that just calls the real executable in the docker image.
 if 'executable' in permissions:
  redirect="""#!/bin/bash
$HOME/subuser/logic/inDocker """+ programName +" $@\n"
  executablePath=getExecutablePath(programName)
  executableFile = open(executablePath,'w')
  executableFile.write(redirect)
  executableFile.close()
  subprocess.call(["chmod","+x",executablePath])
 
 registerProgram(programName,permissions["version"])

def getProgramSrcDir(progName):
 """
 Get the directory where the "source" of the application is stored.  That is the permissions list and the docker-image directory.
 """
 import os
 home = os.path.expanduser("~")
 programSourceDir = os.path.join(home,"subuser","subusers",progName)
 return programSourceDir

def getExecutablePath(progName):
 """
 Get the path to the executable that we will be installing.
 """
 import os
 home = os.path.expanduser("~")
 executablePath = os.path.join(home,"subuser","bin",progName)
 return executablePath

##################################################################

# Should we print a help message
if sys.argv[1] == "help" or sys.argv[1] == "--help" or sys.argv[1] == "-h":
 showHelp()
 exit()

# Are we to use layers from the cache when building the docker image
fromCache = False
if sys.argv[1] == "--from-cache":
 fromCache = True
 programName = sys.argv[2]

# Does the program the user wan't installed exist?
if not os.path.exists(getProgramSrcDir(programName)):
 print(programName+" not available for instaliation.")
 showHelp()
else:
 installProgram()


